<html xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:mshelp="http://msdn.microsoft.com/mshelp" xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:msxsl="urn:schemas-microsoft-com:xslt"><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8" /><META NAME="save" CONTENT="history" /><title>Utilisation des types de données avancés</title><meta name="Language" content="fr-fr" /><meta name="System.Keywords" content="types de données avancés" /><meta name="Microsoft.Help.Id" content="b39461d3-48d6-4048-8300-1a886c00756d" /><meta name="Description" content="Le Pilote JDBC Microsoft pour SQL Server utilise les types de données avancés JDBC pour convertir les types de données SQL Server en un format compréhensible par le langage de programmation Java." /><meta name="Microsoft.Help.ContentType" content="Concepts" /><link rel="stylesheet" type="text/css" href="../local/Classic.css" /><script type="text/javascript" src="../scripts/EventUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/SplitScreen.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/Dropdown.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_manifold.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_feedBack.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CheckboxMenu.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CommonUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../local/script_main.js">&amp;nbsp;</script></head><body><div id="header"><table id="bottomTable" cellpadding="0" cellspacing="0"><tr><td align="left"><span id="headerBold">Utilisation des types de données avancés</span></td></tr></table><table id="gradientTable"><tr><td class="nsrBottom" background="../icons/gradient.gif" /></tr></table></div><div id="mainSection"><div id="mainBody"><div class="introduction"><p>Le Pilote JDBC Microsoft pour SQL Server utilise les types de données avancés JDBC pour convertir les types de données SQL Server en un format compréhensible par le langage de programmation Java. </p></div><h1 class="heading">Notes</h1><div id="sectionSection0" class="section" name="collapseableSection" style=""><p>Le tableau suivant répertorie les mappages par défaut entre les types de données avancés SQL Server, JDBC et du langage de programmation Java.</p><div class="tableSection"><table width="50%" cellspacing="2" cellpadding="5" frame="lhs"><tr><th><p>Types SQL Server</p></th><th><p>Types JDBC (java.sql.Types)</p></th><th><p>Types langage Java</p></th></tr><tr><td><p>varbinary(max)</p><p>image</p></td><td><p>LONGVARBINARY</p></td><td><p>byte[] (par défaut), Blob, InputStream, String</p></td></tr><tr><td><p>text</p><p>varchar(max)</p></td><td><p>LONGVARCHAR</p></td><td><p>String (par défaut), Clob, InputStream</p></td></tr><tr><td><p>ntext</p><p>nvarchar(max)</p></td><td><p>LONGVARCHAR</p><p>LONGNVARCHAR (Java SE 6.0)</p></td><td><p>String (par défaut), Clob, NClob (Java SE 6.0)</p></td></tr><tr><td><p>xml</p></td><td><p>LONGVARCHAR</p><p>SQLXML (Java SE 6.0)</p></td><td><p>String (par défaut), InputStream, Clob, byte[],Blob, SQLXML (Java SE 6.0)</p></td></tr><tr><td><p>udt</p></td><td><p>VARBINARY</p></td><td><p>String (par défaut), byte[], InputStream</p></td></tr></table></div><p>Les sections suivantes proposent des exemples d'utilisation du pilote JDBC et des types de données avancés.</p></div><h1 class="heading">Types de données BLOB, CLOB et NCLOB</h1><div id="sectionSection1" class="section" name="collapseableSection" style=""><p>Le pilote JDBC implémente toutes les méthodes des interfaces java.sql.Blob, java.sql.Clob et java.sql.NClob. </p><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Les valeurs CLOB peuvent être utilisées avec les types de données SQL Server 2005 (ou ultérieur) de grande valeur. En particulier, les types CLOB peuvent être utilisés avec les types de données <span sdata="langKeyword" value="varchar(max)"><span class="keyword">varchar(max)</span></span> et <span sdata="langKeyword" value="nvarchar(max)"><span class="keyword">nvarchar(max)</span></span>, les types BLOB peuvent être utilisés avec les types de données <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span> et <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, et les types NCLOB peuvent être utilisés avec les types de données <span sdata="langKeyword" value="ntext"><span class="keyword">ntext</span></span> et <span sdata="langKeyword" value="nvarchar(max)"><span class="keyword">nvarchar(max)</span></span>.</p></div></div><h1 class="heading">Types de données de grande valeur</h1><div id="sectionSection2" class="section" name="collapseableSection" style=""><p>Dans les versions antérieures de SQL Server, l'utilisation des types de données de grande valeur nécessitait un traitement spécial. Les types de données de grande valeur sont ceux qui dépassent la taille maximale de ligne de 8 Ko. SQL Server propose un spécificateur max pour les types de données <span sdata="langKeyword" value="varchar"><span class="keyword">varchar</span></span>, <span sdata="langKeyword" value="nvarchar"><span class="keyword">nvarchar</span></span> et <span sdata="langKeyword" value="varbinary"><span class="keyword">varbinary</span></span> afin de permettre le stockage des valeurs de 2^31 octets. Les colonnes de tableau et les variables Transact-SQL peuvent spécifier les types de données <span sdata="langKeyword" value="varchar(max)"><span class="keyword">varchar(max)</span></span>, <span sdata="langKeyword" value="nvarchar(max)"><span class="keyword">nvarchar(max)</span></span> ou <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span>.</p><p>Les principaux scénarios de travail sur des types de données de grande valeur impliquent l'extraction d'une base de données ou l'ajout à une base de données. Les sections suivantes décrivent les différentes approches de réalisation de ces tâches.</p><h1 class="heading">Extraction de types de données de grande valeur d'une base de données</h1><div class="subsection"><p>Lors de l'extraction d'une base de données d'un type de données de grande valeur non binaire, tel que <span sdata="langKeyword" value="varchar(max)"><span class="keyword">varchar(max)</span></span>, une approche consiste à lire ces données en tant que flux de caractères. Dans l'exemple suivant, la méthode <a href="599cf463-e19f-4baa-bacb-513cad7c6cd8.htm">executeQuery</a> de la classe <a href="ec24963c-8b51-4838-91e9-1fbfa2347451.htm">SQLServerStatement</a> est utilisée pour extraire des données de la base de données et les retourner dans un jeu de résultats. Ensuite, la méthode <a href="c70e210f-0288-47cc-9268-a29c45979729.htm">getCharacterStream</a> de la classe <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a> est utilisée pour lire les données de grande valeur depuis le jeu de résultats.</p><div class="sampleCode"><span codeLanguage="other"><pre>ResultSet rs = stmt.executeQuery("SELECT TOP 1 * FROM Test1");
rs.next();
Reader reader = rs.getCharacterStream(2);</pre></span></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Cette même approche peut également être utilisée pour les types de données <span sdata="langKeyword" value="text"><span class="keyword">text</span></span>, <span sdata="langKeyword" value="ntext"><span class="keyword">ntext</span></span> et <span sdata="langKeyword" value="nvarchar(max)"><span class="keyword">nvarchar(max)</span></span>.</p></div><p>Lors de l'extraction d'une base de données d'un type de données de grande valeur binaire, tel que <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span>, plusieurs approches s'offrent à vous. La plus efficace consiste à lire les données en tant que flux de données binaire, comme suit :</p><div class="sampleCode"><span codeLanguage="other"><pre>ResultSet rs = stmt.executeQuery("SELECT photo FROM mypics");
rs.next();
InputStream is = rs.getBinaryStream(2);</pre></span></div><p>Vous pouvez également utiliser la méthode <a href="d16a0aea-6144-4fcb-bcbc-5d7daa36d327.htm">getBytes</a> pour lire les données en tant que tableau d'octets, comme suit :</p><div class="sampleCode"><span codeLanguage="other"><pre>ResultSet rs = stmt.executeQuery("SELECT photo FROM mypics");
rs.next();
byte [] b = rs.getBytes(2);</pre></span></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Vous pouvez également lire les donnés en tant que BLOB. Cependant, cette méthode est moins efficace que les deux précédentes.</p></div></div><h1 class="heading">Ajout de types de données de grande valeur à une base de données</h1><div class="subsection"><p>Le téléchargement de données de grande valeur avec le pilote JDBC fonctionne correctement dans les cas de correspondance avec la taille de la mémoire ; dans les cas de dépassement de la taille de la mémoire, la transmission de flux de données en continu constitue l'option principale. Cependant, la méthode la plus efficace consiste à télécharger des données de grande valeur via les interfaces de flux.</p><p>L'utilisation d'une chaîne ou d'octets est également une option, comme suit :</p><div class="sampleCode"><span codeLanguage="other"><pre>PreparedStatement pstmt = con.prepareStatement("INSERT INTO test1 (c1_id, c2_vcmax) VALUES (?, ?)");
pstmt.setInt(1, 1);
pstmt.setString(2, htmlStr);
pstmt.executeUpdate();</pre></span></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Cette approche peut également être utilisée pour les valeurs stockées dans des colonnes <span sdata="langKeyword" value="text"><span class="keyword">text</span></span>, <span sdata="langKeyword" value="ntext"><span class="keyword">ntext</span></span> et <span sdata="langKeyword" value="nvarchar(max)"><span class="keyword">nvarchar(max)</span></span>.</p></div><p>Si vous disposez d'une bibliothèque d'images sur le serveur et que vous devez télécharger des fichiers image binaires dans une colonne <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span>, la méthode la plus efficace impliquant le pilote JDBC consiste à utiliser les flux directement, comme suit :</p><div class="sampleCode"><span codeLanguage="other"><pre>PreparedStatement pstmt = con.prepareStatement("INSERT INTO test1 (Col1, Col2) VALUES(?,?)");
File inputFile = new File("CLOBFile20mb.jpg");
FileInputStream inStream = new FileInputStream(inputFile);
int id = 1;
pstmt.setInt(1,id);
pstmt.setBinaryStream(2, inStream);
pstmt.executeUpdate();
inStream.close();</pre></span></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>L'utilisation de la méthode CLOB ou BLOB n'est pas efficace pour le téléchargement de données de grande valeur.</p></div></div><h1 class="heading">Modification de types de données de grande valeur dans une base de données</h1><div class="subsection"><p>Dans la plupart des cas, la méthode recommandée pour mettre à jour ou modifier des données de grande valeur dans la base de données consiste à transmettre des paramètres via les classes <a href="a8481c06-fbba-432b-8c69-4f4619c20ad4.htm">SQLServerPreparedStatement</a> et <a href="30710a63-c05d-47d9-9cf9-c087a1c76373.htm">SQLServerCallableStatement</a>, à l'aide des commandes Transact-SQL, telles que UPDATE, WRITE et SUBSTRING.</p><p>Si vous devez remplacer l'instance d'un mot dans un fichier texte volumineux, tel qu'un fichier HTML archivé, vous pouvez utiliser un objet <b>Clob</b>, comme suit :</p><div class="sampleCode"><span codeLanguage="other"><pre>String SQL = "SELECT * FROM test1;";
Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
ResultSet rs = stmt.executeQuery(SQL);
rs.next();

Clob clob = rs.getClob(2);
long pos = clob.position("dog", 1);
clob.setString(pos, "cat");
rs.updateClob(2, clob);
rs.updateRow();</pre></span></div><p>De plus, vous pouvez effectuer tout le travail sur le serveur et simplement transmettre les paramètres à une instruction UPDATE préparée.</p><p>Pour plus d'informations sur les types de données de grande valeur, consultez « Utilisation de types de données de grande valeur » dans la documentation en ligne de SQL Server.</p></div></div><h1 class="heading">Type de données XML</h1><div id="sectionSection3" class="section" name="collapseableSection" style=""><p>SQL Server propose un type de données <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> qui vous permet de stocker des documents et des fragments XML dans une base de données SQL Server. Le type de données <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> est un type de données intégré de SQL Server, quelque peu similaire aux autres types intégrés tels que <span sdata="langKeyword" value="int"><span class="keyword">int</span></span> et <span sdata="langKeyword" value="varchar"><span class="keyword">varchar</span></span>. Comme avec les autres types intégrés, vous pouvez utiliser le type de données <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> comme type de colonne lorsque vous créez une table, comme type de variable, type de paramètre, type de retour de fonction ou dans les fonctions CAST et CONVERT Transact-SQL.</p><p>Dans le pilote JDBC, le type de données <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> peut être mappé en tant que chaîne, tableau d'octets, flux, objet CLOB, objet BLOB ou objet SQLXML. Le mappage en tant que chaîne est le mappage par défaut. À partir de la version 2.0 du pilote JDBC, l'API JDBC 4.0 est prise en charge, ce qui permet l'introduction de l'interface SQLXML. L'interface SQLXML définit des méthodes d'interaction et de manipulation des données XML. Le type de données <span sdata="langKeyword" value="SQLXML"><span class="keyword">SQLXML</span></span> est mappé au type de données SQL Server <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span>. Pour plus d'informations sur la lecture et l'écriture de données XML dans la base de données relationnelle avec le type de données Java <span sdata="langKeyword" value="SQLXML"><span class="keyword">SQLXML</span></span>, consultez <span sdata="link"><a href="32b7217e-1f0c-473d-9a45-176daa81584e.htm">Prise en charge des données XML</a></span>.</p><p>L'implémentation du type de données <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> dans le pilote JDBC offre les prises en charge suivantes :</p><ul><li><p>Accès à XML en tant que chaîne standard Java UTF-16 pour les scénarios de programmation les plus courants</p></li><li><p>Entrée de XML en UTF-8 ou codé sur 8 bits</p></li><li><p>Accès à XML en tant que tableau d'octets avec un BOM de début lors de l'encodage en UTF-16 pour l'échange avec d'autres processeurs XML et fichiers de disque</p></li></ul><p>SQL Server requiert un BOM de début pour le XML codé en UTF-16. L'application doit proposer cela si les valeurs de paramètre XML sont fournies en tant que tableaux d'octets. SQL Server sort toujours des valeurs XML sous forme de chaînes en UTF-16 sans BOM ni déclaration d'encodage imbriquée. Lorsque des valeurs XML sont récupérées en tant que byte[], BinaryStream ou Blob, une marque d'ordre d'octet (BOM, Byte-Order Mark) UTF-16 est ajoutée au début de la valeur.</p><p>Pour plus d'informations sur le type de données <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span>, consultez « Type de données XML » dans la documentation en ligne de SQL Server.</p></div><h1 class="heading">Type de données défini par l'utilisateur</h1><div id="sectionSection4" class="section" name="collapseableSection" style=""><p>L'introduction des types définis par l'utilisateur (User-Defined Types, UDT) dans SQL Server 2005 étend le système de types SQL en vous permettant de stocker des objets et des structures de données personnalisées dans une base de données SQL Server. Les UDT peuvent contenir plusieurs types de données et avoir des comportements, ce qui les différencie des types de données alias traditionnels qui ne comprennent qu'un seul type de données système SQL Server. Les types UDT sont définis à l'aide d'un des langages pris en charge par le CLR (Common Language Runtime) Microsoft .NET produisant un code vérifiable. Cela inclut Microsoft Visual C# et Visual Basic .NET. Les données sont exposées en tant que champs et propriétés d'une classe ou structure basée sur le .NET Framework ; par ailleurs, les comportements sont définis par les méthodes de la classe ou de la structure. </p><p>Dans SQL Server, un type UDT peut être utilisé en tant que définition de colonne d'une table, en tant que variable dans un lot Transact-SQL ou en tant qu'argument d'une fonction ou procédure stockée Transact-SQL.</p><p>Pour plus d'informations sur les types de données définis par l'utilisateur, consultez « Utilisation et modification des instances de types de données définis par l'utilisateur » dans la documentation en ligne de SQL Server.</p></div><span id="seeAlsoSpan"><h1 class="heading">Voir aussi</h1></span><div id="seeAlsoSection" class="section" name="collapseableSection" style=""><div class="seeAlsoStyle"><span sdata="link"><a href="7802328d-4d23-4775-9573-4169b127d258.htm">Présentation des types de données de pilote JDBC</a></span></div></div></div><div id="footer" class="section"><span id="feedbackarea">Envoyez vos <a href="javascript:SubmitFeedback('DevDocs@Microsoft.com','','','','8.0.12060.10000','%0\dMerci pour vos commentaires qui permettent aux équipes chargées de rédiger la documentation développeur d\'en améliorer la qualité. Pendant la révision de vos commentaires, il est possible que nous vous contactions par courrier électronique afin de vous demander des éclaircissements ou d\'autres commentaires sur la solution envisagée. Nous n\'utilisons pas votre adresse de messagerie dans un autre but et nous la supprimons une fois notre révision terminée.%0\APour plus d\'informations sur les politiques de confidentialité de Microsoft, consultez http://privacy.microsoft.com/fr-fr/default.aspx.%0\A%0\d','Commentaires client.');">commentaires</a> sur cette rubrique à Microsoft.</span><span id="copyrightarea"><p><a href="9bad553b-9e70-4696-8499-2e35f772a1e0.htm">© 2012 Microsoft. Tous droits réservés.</a></p></span></div></div></body></html>