<html xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:mshelp="http://msdn.microsoft.com/mshelp" xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:msxsl="urn:schemas-microsoft-com:xslt"><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8" /><META NAME="save" CONTENT="history" /><title>Conversions de types de données</title><meta name="Language" content="fr-fr" /><meta name="System.Keywords" content="conversions de type de données" /><meta name="Microsoft.Help.Id" content="98fa7488-aac3-45b4-8aa4-83ed6ab638b4" /><meta name="Description" content="Pour faciliter la conversion des types de données du langage de programmation Java en types de données SQL Server, le Pilote JDBC Microsoft pour SQL Server assure les conversions des types de données requises par la spécification JDBC." /><meta name="Microsoft.Help.ContentType" content="Concepts" /><link rel="stylesheet" type="text/css" href="../local/Classic.css" /><script type="text/javascript" src="../scripts/EventUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/SplitScreen.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/Dropdown.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_manifold.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_feedBack.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CheckboxMenu.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CommonUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../local/script_main.js">&amp;nbsp;</script></head><body><div id="header"><table id="bottomTable" cellpadding="0" cellspacing="0"><tr><td align="left"><span id="headerBold">Conversions de types de données</span></td></tr></table><table id="gradientTable"><tr><td class="nsrBottom" background="../icons/gradient.gif" /></tr></table></div><div id="mainSection"><div id="mainBody"><div class="introduction"><p>Pour faciliter la conversion des types de données du langage de programmation Java en types de données SQL Server, le Pilote JDBC Microsoft pour SQL Server assure les conversions des types de données requises par la spécification JDBC. Pour une flexibilité accrue, tous les types sont convertibles vers et depuis les types de données <span sdata="langKeyword" value="Object"><span class="keyword">Object</span></span>, <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> et <span sdata="langKeyword" value="byte[]"><span class="keyword">byte[]</span></span>. </p></div><h1 class="heading">Conversions de méthode d'accesseur Get</h1><div id="sectionSection0" class="section" name="collapseableSection" style=""><p>Le tableau suivant, basé sur les types de données SQL Server, présente le mappage des conversions du pilote JDBC pour les méthodes <b>get&lt;Type&gt;()</b> de la classe <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a>, ainsi que les conversions prises en charge pour les méthodes <b>get&lt;Type&gt;</b> de la classe <a href="30710a63-c05d-47d9-9cf9-c087a1c76373.htm">SQLServerCallableStatement</a>.</p><img alt="JDBCGetterConversions" src="../art/JDBCGetterConversions.gif" /><p>Trois catégories de conversions sont prises en charge par les méthodes d'accesseur Get du pilote JDBC :</p><ul><li><p><span class="label">Sans perte (x)</span> : conversions pour les cas où le type getter est identique ou plus petit que le type de serveur sous-jacent. Par exemple, lors de l'appel de la méthode <b>getBigDecimal</b> sur une colonne décimale de serveur sous-jacente, aucune conversion n'est nécessaire.</p></li><li><p><span class="label">Converti (y)</span> : conversions de types de serveurs numériques en types de langage Java où la conversion est ordinaire et suit les règles de conversion de langage Java. Pour ces conversions, la précision est toujours tronquée (jamais arrondie) et les dépassements sont gérés comme un opérateur modulo du type de destination, qui est plus petit. Par exemple, l'appel de <b>getInt</b> sur une colonne <span sdata="langKeyword" value="decimal"><span class="keyword">decimal</span></span> sous-jacente qui contient « 1,9999 » retournera « 1 » ou, si la valeur <span sdata="langKeyword" value="decimal"><span class="keyword">decimal</span></span> sous-jacente est « 3000000000 », la valeur <span sdata="langKeyword" value="int"><span class="keyword">int</span></span> engendre un dépassement à « -1294967296 ».</p></li><li><p><span class="label">Dépendant des données (z)</span> : les conversions de types de caractères sous-jacents en types numériques requièrent que les types de caractères contiennent des valeurs pouvant être converties dans ces types. Aucune autre conversion n'a lieu. Si la valeur est trop élevée pour le type getter, elle n'est pas valide. Par exemple, en cas d'appel de la méthode <b>getInt</b> sur une colonne varchar(50) contenant « 53 », la valeur est retournée comme <span sdata="langKeyword" value="int"><span class="keyword">int</span></span> ; en revanche, si la valeur sous-jacente est « xyz » ou « 3000000000 », une erreur est générée.</p></li></ul><p>Si <b>getString</b> est appelé sur un type de données de colonne <span sdata="langKeyword" value="binary"><span class="keyword">binary</span></span>, <span sdata="langKeyword" value="varbinary"><span class="keyword">varbinary</span></span>, <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span> ou <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, la valeur est retournée en tant que valeur de chaîne hexadécimale.</p></div><h1 class="heading">Conversions de méthodes Updater</h1><div id="sectionSection1" class="section" name="collapseableSection" style=""><p>Pour les données typées Java passées aux méthodes <b>update&lt;Type&gt;()</b> de la classe <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a>, les conversions suivantes s'appliquent.</p><img alt="JDBCUpdaterConversions" src="../art/JDBC_JDBCUpdatterConversions.gif" /><p>Trois catégories de conversions sont prises en charge par les méthodes updater du pilote JDBC :</p><ul><li><p><span class="label">Sans perte (x)</span> : conversions pour les cas où le type updater est identique ou plus petit que le type de serveur sous-jacent. Par exemple, lors de l'appel de la méthode <b>updateBigDecimal</b> sur une colonne décimale de serveur sous-jacente, aucune conversion n'est nécessaire.</p></li><li><p><span class="label">Converti (y)</span> : conversions de types de serveurs numériques en types de langage Java où la conversion est ordinaire et suit les règles de conversion de langage Java. Pour ces conversions, la précision est toujours tronquée (jamais arrondie) et le dépassement de capacité est géré en tant que modulo du type de destination (type le plus petit). Par exemple, l'appel de <b>updateDecimal</b> sur une colonne <span sdata="langKeyword" value="int"><span class="keyword">int</span></span> sous-jacente qui contient « 1,9999 » retourne « 1 » ; par ailleurs, si la valeur <span sdata="langKeyword" value="decimal"><span class="keyword">decimal</span></span> sous-jacente est « 3000000000 », la valeur <span sdata="langKeyword" value="int"><span class="keyword">int</span></span> engendre un dépassement de capacité égal à « -1294967296 ».</p></li><li><p><span class="label">Dépendant des données (z)</span> : les conversions des types de données sources sous-jacents en types de données de destination nécessitent que les valeurs contenues puissent être converties en types de destination. Aucune autre conversion n'a lieu. Si la valeur est trop élevée pour le type getter, elle n'est pas valide. Par exemple, si <b>updateString</b> est appelé sur une colonne int qui contient « 53 », la mise à jour réussit ; toutefois, si la valeur String sous-jacente est « foo » ou « 3000000000 », une erreur est générée.</p></li></ul><p>Lorsque <b>updateString</b> est appelé sur un type de données de colonne <span sdata="langKeyword" value="binary"><span class="keyword">binary</span></span>, <span sdata="langKeyword" value="varbinary"><span class="keyword">varbinary</span></span>, <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span> ou <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, il gère la valeur String en tant que valeur de chaîne hexadécimale.</p><p>Lorsque le type de données de colonne SQL Server est <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span>, la valeur de données doit avoir un type <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span> valide. Lors de l'appel des méthodes <b>updateBytes</b>, <b>updateBinaryStream</b> ou <b>updateBlob</b>, la valeur de données doit être la représentation sous forme de chaîne hexadécimale des caractères XML. Exemple : </p><div class="sampleCode"><span codeLanguage="other"><pre>&lt;hello&gt;world&lt;/hello&gt; = 0x3C68656C6C6F3E776F726C643C2F68656C6C6F3E </pre></span></div><p>Notez qu'une marque d'ordre d'octet (BOM, Byte-Order Mark) est obligatoire si les caractères XML correspondent à des encodages de caractères spécifiques.</p></div><h1 class="heading">Conversions de méthodes setter</h1><div id="sectionSection2" class="section" name="collapseableSection" style=""><p>Pour les données typées Java passées aux méthodes <b>set&lt;Type&gt;()</b> de la classe <a href="a8481c06-fbba-432b-8c69-4f4619c20ad4.htm">SQLServerPreparedStatement</a> et de la classe <a href="30710a63-c05d-47d9-9cf9-c087a1c76373.htm">SQLServerCallableStatement</a>, les conversions suivantes s'appliquent.</p><img alt="JDBCSetterConversions" src="../art/JDBC_JDBCSetterConversions_v2.gif" /><p>Le serveur tente toutes les conversions et retourne des erreurs en cas d'échec.</p><p>Dans le cas du type de données <span sdata="langKeyword" value="String"><span class="keyword">String</span></span>, si la valeur dépasse la longueur de <span sdata="langKeyword" value="VARCHAR"><span class="keyword">VARCHAR</span></span>, il est mappé à <span sdata="langKeyword" value="LONGVARCHAR"><span class="keyword">LONGVARCHAR</span></span>. De même, <span sdata="langKeyword" value="NVARCHAR"><span class="keyword">NVARCHAR</span></span> est mappé à <span sdata="langKeyword" value="LONGNVARCHAR"><span class="keyword">LONGNVARCHAR</span></span> si la valeur dépasse la longueur prise en charge de <span sdata="langKeyword" value="NVARCHAR"><span class="keyword">NVARCHAR</span></span>. Il en va de même pour <span sdata="langKeyword" value="byte[]"><span class="keyword">byte[]</span></span>. Les valeurs plus longues que <span sdata="langKeyword" value="VARBINARY"><span class="keyword">VARBINARY</span></span> deviennent <span sdata="langKeyword" value="LONGVARBINARY"><span class="keyword">LONGVARBINARY</span></span>.</p><p>Deux catégories de conversions sont prises en charge par les méthodes setter du pilote JDBC :</p><ul><li><p><span class="label">Sans perte (x)</span> : conversions pour les cas où le type setter est identique ou plus petit que le type de serveur sous-jacent. Par exemple, lors de l'appel de la méthode <b>setBigDecimal</b> sur une colonne <span sdata="langKeyword" value="decimal"><span class="keyword">decimal</span></span> de serveur sous-jacente, aucune conversion n'est nécessaire. Pour les conversions de numérique à caractère, le type de données <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> Java est converti en <span sdata="langKeyword" value="String"><span class="keyword">String</span></span>. Par exemple, l'appel de <b>setDouble</b> avec une valeur « 53 » sur une colonne varchar(50) produit une valeur de caractère « 53 » dans cette colonne de destination.</p></li><li><p><span class="label">Converti (y)</span> : conversions d'un type <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> Java vers un type <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> de serveur sous-jacent qui est plus petit. Ces conversions sont de type ordinaire et suivent les conventions de conversion SQL Server. La précision est toujours tronquée (jamais arrondie) et tout dépassement de capacité génère une erreur de conversion non prise en charge. Par exemple, l'utilisation de <b>updateDecimal</b> avec la valeur « 1,9999 » sur une colonne d'entiers sous-jacente produit « 1 » dans la colonne de destination ; en revanche, si la valeur « 3000000000 » est passée, le pilote génère une erreur.</p></li><li><p><span class="label">Dépendant des données (z)</span> : les conversions d'un type <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> Java en type de données SQL Server sous-jacent dépendent des conditions suivantes : le pilote envoie la valeur <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> à SQL Server, puis SQL Server effectue les conversions appropriées, le cas échéant. Si <b>sendStringParametersAsUnicode</b> a la valeur True et si le type de données SQL Server sous-jacent est <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, SQL Server ne permet pas la conversion de <span sdata="langKeyword" value="nvarchar"><span class="keyword">nvarchar</span></span> en <span sdata="langKeyword" value="image"><span class="keyword">image</span></span> ; en outre, l'exception est <b>SQLServerException</b> est levée. Si sendStringParametersAsUnicode a la valeur False et si le type de données SQL Server sous-jacent est <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, SQL Server permet la conversion de <span sdata="langKeyword" value="varchar"><span class="keyword">varchar</span></span> en <span sdata="langKeyword" value="image"><span class="keyword">image</span></span> et aucune exception n'est levée.</p></li></ul><p>SQL Server effectue les conversions et retourne les erreurs au pilote JDBC en cas de problème.</p><p>Lorsque le type de données de colonne SQL Server est <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span>, la valeur de données doit avoir un type <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span> valide. Lors de l'appel des méthodes <b>updateBytes</b>, <b>updateBinaryStream</b> ou <b>updateBlob</b>, la valeur de données doit être la représentation sous forme de chaîne hexadécimale des caractères XML. Exemple : </p><div class="sampleCode"><span codeLanguage="other"><pre>&lt;hello&gt;world&lt;/hello&gt; = 0x3C68656C6C6F3E776F726C643C2F68656C6C6F3E </pre></span></div><p>Notez qu'une marque d'ordre d'octet (BOM, Byte-Order Mark) est obligatoire si les caractères XML correspondent à des encodages de caractères spécifiques.</p></div><h1 class="heading">Conversions sur setObject</h1><div id="sectionSection3" class="section" name="collapseableSection" style=""><p>Pour les données typées Java passées aux méthodes <b>setObject(&lt;Type&gt;)</b> de la classe <a href="a8481c06-fbba-432b-8c69-4f4619c20ad4.htm">SQLServerPreparedStatement</a>, les conversions suivantes s'appliquent. </p><img alt="JDBCSetObjectConversions" src="../art/JDBC_JDBCSetObjectConversions.gif" /><p>La méthode <b>setObject</b> sans type cible spécifié utilise le mappage par défaut. Dans le cas du type de données <span sdata="langKeyword" value="String"><span class="keyword">String</span></span>, si la valeur dépasse la longueur de <span sdata="langKeyword" value="VARCHAR"><span class="keyword">VARCHAR</span></span>, il est mappé à <span sdata="langKeyword" value="LONGVARCHAR"><span class="keyword">LONGVARCHAR</span></span>. De même, <span sdata="langKeyword" value="NVARCHAR"><span class="keyword">NVARCHAR</span></span> est mappé à <span sdata="langKeyword" value="LONGNVARCHAR"><span class="keyword">LONGNVARCHAR</span></span> si la valeur dépasse la longueur prise en charge de <span sdata="langKeyword" value="NVARCHAR"><span class="keyword">NVARCHAR</span></span>. Il en va de même pour <span sdata="langKeyword" value="byte[]"><span class="keyword">byte[]</span></span>. Les valeurs plus longues que <span sdata="langKeyword" value="VARBINARY"><span class="keyword">VARBINARY</span></span> deviennent <span sdata="langKeyword" value="LONGVARBINARY"><span class="keyword">LONGVARBINARY</span></span>.</p><p>Trois catégories de conversions sont prises en charge par les méthodes setObject du pilote JDBC :</p><ul><li><p><span class="label">Sans perte (x)</span> : conversions pour les cas où le type setter est identique ou plus petit que le type de serveur sous-jacent. Par exemple, lors de l'appel de la méthode <b>setBigDecimal</b> sur une colonne <span sdata="langKeyword" value="decimal"><span class="keyword">decimal</span></span> de serveur sous-jacente, aucune conversion n'est nécessaire. Pour les conversions de numérique à caractère, le type de données <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> Java est converti en <span sdata="langKeyword" value="String"><span class="keyword">String</span></span>. Par exemple, l'appel de la méthode <b>setDouble</b> avec une valeur « 53 » sur une colonne varchar(50) produit une valeur de caractère « 53 » dans cette colonne de destination.</p></li><li><p><span class="label">Converti (y)</span> : conversions d'un type <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> Java vers un type <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> de serveur sous-jacent qui est plus petit. Ces conversions sont de type ordinaire et suivent les conventions de conversion SQL Server. La précision est toujours tronquée (jamais arrondie) et les dépassements génèrent une erreur de conversion non prise en charge. Par exemple, l'utilisation de <b>updateDecimal</b> avec la valeur « 1,9999 » sur une colonne d'entiers sous-jacente produit « 1 » dans la colonne de destination ; en revanche, si la valeur « 3000000000 » est passée, le pilote génère une erreur.</p></li><li><p><span class="label">Dépendant des données (z)</span> : les conversions d'un type <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> Java en type de données SQL Server sous-jacent dépendent des conditions suivantes : le pilote envoie la valeur <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> à SQL Server, puis SQL Server effectue les conversions appropriées, le cas échéant. Si la propriété de connexion <b>sendStringParametersAsUnicode</b> a la valeur True et si le type de données SQL Serversous-jacent est <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, SQL Server ne permet pas la conversion de <span sdata="langKeyword" value="nvarchar"><span class="keyword">nvarchar</span></span> en <span sdata="langKeyword" value="image"><span class="keyword">image</span></span> ; en outre, l'exception SQLServerException est levée. Si <b>sendStringParametersAsUnicode</b> a la valeur False et si le type de données SQL Server sous-jacent est <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, SQL Server permet la conversion de <span sdata="langKeyword" value="varchar"><span class="keyword">varchar</span></span> en <span sdata="langKeyword" value="image"><span class="keyword">image</span></span> et aucune exception n'est levée.</p></li></ul><p>SQL Server effectue les conversions de définitions en masse et retourne les erreurs au pilote JDBC en cas de problème. Les conversions côté client constituent l'exception et sont effectuées uniquement dans le cas des valeurs <span sdata="langKeyword" value="date"><span class="keyword">date</span></span>, <span sdata="langKeyword" value="time"><span class="keyword">time</span></span>, <span sdata="langKeyword" value="timestamp"><span class="keyword">timestamp</span></span>, <span sdata="langKeyword" value="Boolean"><span class="keyword">Boolean</span></span> et <span sdata="langKeyword" value="String"><span class="keyword">String</span></span>.</p><p>Lorsque le type de données de colonne SQL Server est <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span>, la valeur de données doit avoir un type <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span> valide. Lors de l'appel des méthodes setObject(byte[], SQLXML), setObject(inputStream, SQLXML) ou setObject(Blob, SQLXML), la valeur de données doit être la représentation sous forme de chaîne hexadécimale des caractères XML. Exemple : </p><div class="sampleCode"><span codeLanguage="other"><pre>&lt;hello&gt;world&lt;/hello&gt; = 0x3C68656C6C6F3E776F726C643C2F68656C6C6F3E </pre></span></div><p>Notez qu'une marque d'ordre d'octet (BOM, Byte-Order Mark) est obligatoire si les caractères XML correspondent à des encodages de caractères spécifiques.</p></div><span id="seeAlsoSpan"><h1 class="heading">Voir aussi</h1></span><div id="seeAlsoSection" class="section" name="collapseableSection" style=""><div class="seeAlsoStyle"><span sdata="link"><a href="7802328d-4d23-4775-9573-4169b127d258.htm">Présentation des types de données de pilote JDBC</a></span></div></div></div><div id="footer" class="section"><span id="feedbackarea">Envoyez vos <a href="javascript:SubmitFeedback('DevDocs@Microsoft.com','','','','8.0.12060.10000','%0\dMerci pour vos commentaires qui permettent aux équipes chargées de rédiger la documentation développeur d\'en améliorer la qualité. Pendant la révision de vos commentaires, il est possible que nous vous contactions par courrier électronique afin de vous demander des éclaircissements ou d\'autres commentaires sur la solution envisagée. Nous n\'utilisons pas votre adresse de messagerie dans un autre but et nous la supprimons une fois notre révision terminée.%0\APour plus d\'informations sur les politiques de confidentialité de Microsoft, consultez http://privacy.microsoft.com/fr-fr/default.aspx.%0\A%0\d','Commentaires client.');">commentaires</a> sur cette rubrique à Microsoft.</span><span id="copyrightarea"><p><a href="9bad553b-9e70-4696-8499-2e35f772a1e0.htm">© 2012 Microsoft. Tous droits réservés.</a></p></span></div></div></body></html>