<html xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:mshelp="http://msdn.microsoft.com/mshelp" xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:msxsl="urn:schemas-microsoft-com:xslt"><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8" /><META NAME="save" CONTENT="history" /><title>Utilisation de la mise en mémoire tampon adaptative</title><meta name="Language" content="fr-fr" /><meta name="System.Keywords" content="adaptative" /><meta name="System.Keywords" content="mise en mémoire tampon adaptative" /><meta name="System.Keywords" content="isWrapperFor" /><meta name="System.Keywords" content="selectMethod" /><meta name="System.Keywords" content="unwrap" /><meta name="Microsoft.Help.Id" content="92d4e3be-c3e9-4732-9a60-b57f4d0f7cb7" /><meta name="Description" content="La mise en mémoire tampon adaptative est conçue pour récupérer tout type de données de valeur importante sans la charge mémoire associée aux curseurs côté serveur." /><meta name="Microsoft.Help.ContentType" content="Concepts" /><link rel="stylesheet" type="text/css" href="../local/Classic.css" /><script type="text/javascript" src="../scripts/EventUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/SplitScreen.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/Dropdown.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_manifold.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_feedBack.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CheckboxMenu.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CommonUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../local/script_main.js">&amp;nbsp;</script></head><body><div id="header"><table id="bottomTable" cellpadding="0" cellspacing="0"><tr><td align="left"><span id="headerBold">Utilisation de la mise en mémoire tampon adaptative</span></td></tr></table><table id="gradientTable"><tr><td class="nsrBottom" background="../icons/gradient.gif" /></tr></table></div><div id="mainSection"><div id="mainBody"><div class="introduction"><p>La mise en mémoire tampon adaptative est conçue pour récupérer tout type de données de valeur importante sans la charge mémoire associée aux curseurs côté serveur. Les applications peuvent utiliser la fonctionnalité de mise en mémoire tampon adaptative avec toutes les versions de SQL Server qui sont prises en charge par le pilote.</p><p>Normalement, lorsque le Pilote JDBC Microsoft pour SQL Server exécute une requête, il extrait tous les résultats du serveur dans la mémoire d'application. Bien que cette approche réduise la consommation des ressources sur l'ordinateur SQL Server, elle peut lever une exception <b>OutOfMemoryError</b> dans l'application JDBC pour les requêtes qui produisent des résultats très grands.</p><p>Pour permettre aux applications de gérer des résultats très volumineux, le Pilote JDBC Microsoft pour SQL Server fournit la mise en mémoire tampon adaptative. Avec la mise en mémoire tampon adaptative, le pilote récupère les résultats de l'exécution des instructions à partir du serveur SQL Server chaque fois que l'application en a besoin, et non en une seule fois. Le pilote ignore également les résultats dès que l'application ne peut plus y accéder. Voici quelques exemples de situations où la mise en mémoire tampon adaptative peut être utile : </p><ul><li><p><b>La requête produit un jeu de résultats très grand :</b> l'application peut exécuter une instruction SELECT qui produit davantage de lignes que l'application ne peut stocker en mémoire. Dans les versions précédentes, l'application devait utiliser un curseur côté serveur pour éviter une erreur <b>OutOfMemoryError</b>. La mise en mémoire tampon adaptative permet d'effectuer un passage en lecture seule avant uniquement d'un jeu de résultats arbitrairement volumineux sans nécessiter de curseur côté serveur. </p></li><li><p><b>La requête produit des colonnes </b><a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a><b> ou des valeurs de paramètres OUT </b><a href="30710a63-c05d-47d9-9cf9-c087a1c76373.htm">SQLServerCallableStatement</a><b> très volumineuses :</b> l'application peut récupérer une valeur unique (colonne ou paramètre OUT) dont la taille est trop importante pour la mémoire de l'application. La mise en mémoire tampon adaptative permet à l'application cliente d'extraire une telle valeur en tant que flux, en utilisant les méthodes <b>getAsciiStream</b>, <b>getBinaryStream,</b> ou <b>getCharacterStream</b>. L'application récupère la valeur à partir du serveur SQL Server à mesure qu'elle lit le flux.</p><p /></li></ul><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Avec la mise en mémoire tampon adaptative, le pilote JDBC ne met en mémoire tampon que la quantité de données requise. Le pilote ne fournit aucune méthode publique pour contrôler ou limiter la taille de la mémoire tampon.</p></div></div><h1 class="heading">Définition de la mise en mémoire tampon adaptative</h1><div id="sectionSection0" class="section" name="collapseableSection" style=""><p>À partir de la version 2.0 du pilote JDBC, le comportement par défaut du pilote est « <span sdata="langKeyword" value="adaptive"><span class="keyword">adaptive</span></span> ». En d'autres termes, pour pouvoir obtenir le comportement de mise en mémoire tampon adaptative, votre application n'a pas besoin de requérir explicitement le mode de mise en mémoire tampon adaptative. Toutefois, dans la version 1.2, le mode de mise en mémoire tampon était « <span sdata="langKeyword" value="full"><span class="keyword">full</span></span> » par défaut ; par ailleurs, l'application devait requérir explicitement le mode de mise en mémoire tampon adaptative.</p><p>Il existe trois manières pour une application de demander que l'exécution d'instructions utilise la mise en mémoire tampon adaptative :</p><ul><li><p>L'application peut affecter la valeur « adaptive » à la propriété de connexion <span sdata="langKeyword" value="responseBuffering"><span class="keyword">responseBuffering</span></span>. Pour plus d'informations sur la définition des propriétés de connexion, consultez <span sdata="link"><a href="f1b62700-f046-488d-bd6b-a5cd8fc345b7.htm">Définition des propriétés de connexion</a></span>. </p></li><li><p>L'application peut utiliser la méthode <a href="c9e43ff2-8117-4dca-982d-83c863d0c8e1.htm">setResponseBuffering</a> de l'objet <a href="097434fd-2b74-411c-a5ed-eba04481dde5.htm">SQLServerDataSource</a> pour définir le mode de mise en mémoire tampon de la réponse pour toutes les connexions créées par le biais de cet objet <a href="097434fd-2b74-411c-a5ed-eba04481dde5.htm">SQLServerDataSource</a>.</p></li><li><p>L'application peut utiliser la méthode <a href="9f489835-6cda-4c8c-b139-079639a169cf.htm">setResponseBuffering</a> de la classe <a href="ec24963c-8b51-4838-91e9-1fbfa2347451.htm">SQLServerStatement</a> pour définir le mode de mise en mémoire tampon de la réponse pour un objet statement particulier. </p></li></ul><p>Lors de l'utilisation du pilote JDBC version 1.2, les applications devaient effectuer une conversion de type (transtypage) de l'objet statement vers une classe <a href="ec24963c-8b51-4838-91e9-1fbfa2347451.htm">SQLServerStatement</a> pour pouvoir utiliser la méthode <a href="9f489835-6cda-4c8c-b139-079639a169cf.htm">setResponseBuffering</a>. Les exemples de code dans les rubriques <span sdata="link"><a href="6c986144-3854-4352-8331-e79eccbefc28.htm">Exemple de lecture de données volumineuses</a></span> et <span sdata="link"><a href="58c76635-a117-4661-8781-d6cb231c5809.htm">Exemple de lecture de données volumineuses avec des procédures stockées</a></span> illustrent cet ancien mode d'utilisation. </p><p>Toutefois, avec le pilote JDBC version 2.0, les applications peuvent utiliser les méthodes <a href="53f3291f-d43a-476b-a656-d86168dacf6c.htm">isWrapperFor</a> et <a href="ce680176-ef04-4e44-bb6c-ec50bd06e7e6.htm">unwrap</a> pour accéder aux fonctionnalités spécifiques aux fournisseurs sans hypothèse relative à la hiérarchie de la classe d'implémentation. Pour obtenir un exemple de code, consultez la rubrique <span sdata="link"><a href="76ecc05f-a77d-40a2-bab9-91a7fcf17347.htm">Exemple de mise à jour de données volumineuses</a></span>.</p></div><h1 class="heading">Récupération de données volumineuses avec la mise en mémoire tampon adaptative</h1><div id="sectionSection1" class="section" name="collapseableSection" style=""><p>Lorsque de grandes valeurs sont lues une fois à l'aide des méthodes get&lt;Type&gt;Stream et que l'accès aux colonnes ResultSet et aux paramètres OUT CallableStatement s'effectue dans l'ordre retourné par le serveur SQL Server, la mise en mémoire tampon adaptative réduit l'utilisation de la mémoire de l'application lors du traitement des résultats. Lors de l'utilisation de la mise en mémoire tampon adaptative :</p><ul><li><p>Les méthodes <b>get&lt;Type&gt;Stream</b> définies dans les classes <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a> et <a href="30710a63-c05d-47d9-9cf9-c087a1c76373.htm">SQLServerCallableStatement</a> retournent des flux à lecture unique par défaut, bien que les flux puissent être réinitialisés s'ils sont marqués par l'application. Si l'application souhaite effectuer un <span class="code">reset</span> du flux, elle doit d'abord appeler la méthode <span class="code">mark</span> sur ce flux. </p></li><li><p>Les méthodes <b>get&lt;Type&gt;Stream</b> définies dans les classes <a href="24170524-e1ab-4e80-8fd1-6688efacfbde.htm">SQLServerClob</a> et <a href="88bd8623-889d-4b5d-99ff-c85b32f3ff5c.htm">SQLServerBlob</a> retournent des flux qui peuvent toujours être repositionnés à la position de départ du flux sans appeler la méthode <span class="code">mark</span>. </p></li></ul><p>Lorsque l'application utilise la mise en mémoire tampon adaptative, les valeurs extraites par les méthodes <b>get&lt;Type&gt;Stream</b> peuvent être extraites une seule fois. Si vous essayez d'appeler toute méthode <b>get&lt;Type&gt;</b> sur la même colonne ou le même paramètre après avoir appelé la méthode <b>get&lt;Type&gt;Stream</b> du même objet, une exception est levée avec le message « Un utilisateur a accédé aux données et elles ne sont pas disponibles pour cette colonne ou ce paramètre ».</p></div><h1 class="heading">Consignes pour l'utilisation de la mise en mémoire tampon adaptative</h1><div id="sectionSection2" class="section" name="collapseableSection" style=""><p>Les développeurs doivent respecter les recommandations importantes suivantes afin de réduire l'utilisation de la mémoire par l'application :</p><ul><li><p>Évitez d'utiliser la propriété de chaîne de connexion <span sdata="langKeyword" value="selectMethod=cursor"><span class="keyword">selectMethod=cursor</span></span> pour permettre à l'application de traiter un jeu de résultats très volumineux. La fonctionnalité de mise en mémoire tampon adaptative permet aux applications de traiter de très grands jeux de résultats avant uniquement en lecture seule sans utiliser de curseur côté serveur. Notez que, lorsque vous définissez <span sdata="langKeyword" value="selectMethod=cursor"><span class="keyword">selectMethod=cursor</span></span>, tous les jeux de résultats en lecture seule de type avant produits par cette connexion sont affectés. En d'autres termes, si votre application traite régulièrement des jeux de résultats de petite taille avec peu de lignes, la création, la lecture et la fermeture d'un curseur côté serveur pour chaque jeu de résultats utilisera  plus de ressources à la fois côté client et côté serveur que dans le cas où <span sdata="langKeyword" value="selectMethod"><span class="keyword">selectMethod</span></span> n'a pas la valeur <span sdata="langKeyword" value="cursor"><span class="keyword">cursor</span></span>.</p></li><li><p>Lisez les grandes valeurs de texte ou binaires en tant que flux en utilisant les méthodes <b>getAsciiStream</b>, <b>getBinaryStream,</b> ou <b>getCharacterStream</b> à la place des méthodes <b>getBlob</b> ou <b>getClob</b>. À partir de la version 1.2, la classe <a href="30710a63-c05d-47d9-9cf9-c087a1c76373.htm">SQLServerCallableStatement</a> fournit de nouvelles méthodes <b>get&lt;Type&gt;Stream</b> à cet effet.</p></li><li><p>Assurez-vous que les colonnes avec des valeurs potentiellement grandes sont placées en dernier dans la liste de colonnes dans une instruction SELECT et que les méthodes <b>get&lt;Type&gt;Stream</b> du <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a> sont utilisées pour accéder aux colonnes dans l'ordre dans lequel elles sont sélectionnées.</p></li><li><p>Assurez-vous que les paramètres OUT avec des valeurs potentiellement grandes sont déclarés en dernier dans la liste de paramètres dans le SQL utilisé pour créer le <a href="30710a63-c05d-47d9-9cf9-c087a1c76373.htm">SQLServerCallableStatement</a>. De plus, assurez-vous que les méthodes <b>get&lt;Type&gt;Stream</b> du <a href="30710a63-c05d-47d9-9cf9-c087a1c76373.htm">SQLServerCallableStatement</a> sont utilisées pour accéder aux paramètres OUT dans l'ordre dans lequel ils sont déclarés.</p></li><li><p>Évitez d'exécuter simultanément plusieurs instructions sur la même connexion. L'exécution d'une autre instruction avant le traitement des résultats de l'instruction précédente peut provoquer la mise en mémoire tampon des résultats non traités dans la mémoire d'application.</p></li><li><p>Dans certains cas, il est préférable d'utiliser <span sdata="langKeyword" value="selectMethod=cursor"><span class="keyword">selectMethod=cursor</span></span> plutôt que <span sdata="langKeyword" value="responseBuffering=adaptive"><span class="keyword">responseBuffering=adaptive</span></span>, par exemple :</p><ul><li><p>Si votre application traite un jeu de résultats en lecture seule de type avant lentement, par exemple la lecture de chaque ligne après une entrée utilisateur, l'utilisation de <span sdata="langKeyword" value="selectMethod=cursor"><span class="keyword">selectMethod=cursor</span></span> à la place de <span sdata="langKeyword" value="responseBuffering=adaptive"><span class="keyword">responseBuffering=adaptive</span></span> peut permettre de réduire l'utilisation des ressources par SQL Server. </p></li><li><p>Si votre application traite plusieurs jeux de résultats en lecture seule de type avant simultanément sur la même connexion, l'utilisation de <span sdata="langKeyword" value="selectMethod=cursor"><span class="keyword">selectMethod=cursor</span></span> à la place de <span sdata="langKeyword" value="responseBuffering=adaptive"><span class="keyword">responseBuffering=adaptive</span></span> peut permettre de réduire la mémoire requise par le pilote lors du traitement de ces jeux de résultats.</p></li></ul><p>Dans les deux cas, vous devez tenir compte de la surcharge liée à la création, la lecture et la fermeture des curseurs côté serveur.</p></li></ul><p>En outre, la liste suivante fournit quelques recommandations pour les jeux de résultats de type avant uniquement pouvant être mis à jour et déroulables :</p><ul><li><p>Pour les jeux de résultats déroulables, lors de l'extraction d'un bloc de lignes, le pilote lit toujours en mémoire le nombre de lignes indiqué par la méthode <a href="7bc96930-b0c9-42f6-8df9-1d8d824408b3.htm">getFetchSize</a> de l'objet <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a>, même lorsque la mise en mémoire tampon adaptative est activée. Si le défilement provoque une erreur <b>OutOfMemoryError</b>, vous pouvez réduire le nombre de lignes extraites en appelant la méthode <a href="233bf4f8-4758-42d0-a80b-33e34fa78027.htm">setFetchSize</a> de l'objet <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a> pour affecter un nombre inférieur de lignes à la taille de l'extraction, voire une seule ligne, si nécessaire. Si cela n'empêche pas l'erreur <b>OutOfMemoryError, </b>évitez d'inclure des colonnes très volumineuses dans les jeux de résultats déroulables.</p></li><li><p>Pour les jeux de résultats de type avant uniquement pouvant être mis à jour, lors de l'extraction d'un bloc de lignes, le pilote lit normalement en mémoire le nombre de lignes indiqué par la méthode <a href="7bc96930-b0c9-42f6-8df9-1d8d824408b3.htm">getFetchSize</a> de l'objet <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a>, même lorsque la mise en mémoire tampon adaptative est activée sur la connexion. Si l'appel de la méthode <a href="60248447-6908-4036-a779-a501453cd553.htm">next</a> de l'objet <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a> provoque une erreur <b>OutOfMemoryError</b>, vous pouvez réduire le nombre de lignes extraites en appelant la méthode <a href="233bf4f8-4758-42d0-a80b-33e34fa78027.htm">setFetchSize</a> de l'objet <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a> pour affecter un nombre inférieur de lignes à la taille de l'extraction, voire une seule ligne, si nécessaire. Vous pouvez également forcer le pilote à ne mettre aucune ligne en mémoire en appelant la méthode <a href="9f489835-6cda-4c8c-b139-079639a169cf.htm">setResponseBuffering</a> de l'objet <a href="ec24963c-8b51-4838-91e9-1fbfa2347451.htm">SQLServerStatement</a> avec le paramètre <span sdata="langKeyword" value="adaptive"><span class="keyword">adaptive</span></span> avant d'exécuter l'instruction. Dans la mesure où le jeu de résultats n'est pas déroulable, si l'application accède à une valeur de colonne importante à l'aide de l'une des méthodes <b>get&lt;Type&gt;Stream</b>, le pilote ignore la valeur dès que l'application la lit comme il le fait pour les jeux de résultats en lecture seule de type avant.</p></li></ul></div><span id="seeAlsoSpan"><h1 class="heading">Voir aussi</h1></span><div id="seeAlsoSection" class="section" name="collapseableSection" style=""><div class="seeAlsoStyle"><span sdata="link"><a href="e1592499-b87b-45ee-bab8-beaba8fde841.htm">Amélioration des performances et de la fiabilité avec le pilote JDBC</a></span></div></div></div><div id="footer" class="section"><span id="feedbackarea">Envoyez vos <a href="javascript:SubmitFeedback('DevDocs@Microsoft.com','','','','8.0.12060.10000','%0\dMerci pour vos commentaires qui permettent aux équipes chargées de rédiger la documentation développeur d\'en améliorer la qualité. Pendant la révision de vos commentaires, il est possible que nous vous contactions par courrier électronique afin de vous demander des éclaircissements ou d\'autres commentaires sur la solution envisagée. Nous n\'utilisons pas votre adresse de messagerie dans un autre but et nous la supprimons une fois notre révision terminée.%0\APour plus d\'informations sur les politiques de confidentialité de Microsoft, consultez http://privacy.microsoft.com/fr-fr/default.aspx.%0\A%0\d','Commentaires client.');">commentaires</a> sur cette rubrique à Microsoft.</span><span id="copyrightarea"><p><a href="9bad553b-9e70-4696-8499-2e35f772a1e0.htm">© 2012 Microsoft. Tous droits réservés.</a></p></span></div></div></body></html>