<html xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:mshelp="http://msdn.microsoft.com/mshelp" xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:msxsl="urn:schemas-microsoft-com:xslt"><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8" /><META NAME="save" CONTENT="history" /><title>Fonctionnement des types de curseurs</title><meta name="Language" content="fr-fr" /><meta name="System.Keywords" content="types de curseurs" /><meta name="Microsoft.Help.Id" content="4f4d3db7-4f76-450d-ab63-141237a4f034" /><meta name="Description" content="Les opérations réalisées dans une base de données relationnelle s'exécutent sur un ensemble complet de lignes." /><meta name="Microsoft.Help.ContentType" content="Concepts" /><link rel="stylesheet" type="text/css" href="../local/Classic.css" /><script type="text/javascript" src="../scripts/EventUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/SplitScreen.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/Dropdown.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_manifold.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_feedBack.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CheckboxMenu.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CommonUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../local/script_main.js">&amp;nbsp;</script></head><body><div id="header"><table id="bottomTable" cellpadding="0" cellspacing="0"><tr><td align="left"><span id="headerBold">Fonctionnement des types de curseurs</span></td></tr></table><table id="gradientTable"><tr><td class="nsrBottom" background="../icons/gradient.gif" /></tr></table></div><div id="mainSection"><div id="mainBody"><div class="introduction"><p>Les opérations réalisées dans une base de données relationnelle s'exécutent sur un ensemble complet de lignes. L'ensemble de lignes retourné par une instruction SELECT contient toutes les lignes satisfaisant aux conditions de la clause WHERE de l'instruction. Cet ensemble complet de lignes retourné par l'instruction est appelé jeu de résultats. Les applications peuvent ne pas toujours fonctionner efficacement si le jeu de résultats est traité comme une unité. Ces applications ont besoin d'un mécanisme leur permettant de travailler avec une seule ligne ou avec un petit bloc de lignes à la fois. Les curseurs sont une extension des jeux de résultats qui procurent ce mécanisme. </p><p>Les curseurs étendent le traitement des jeux de résultats en effectuant les opérations suivantes :</p><ul><li><p>Ils permettent de vous positionner sur des lignes spécifiques du jeu de résultats.</p></li><li><p>Ils extraient une ligne ou un bloc de lignes à partir de la position actuelle dans le jeu de résultats.</p></li><li><p>Ils prennent en charge les modifications de données apportées à la ligne à la position actuelle dans le jeu de résultats.</p></li><li><p>Ils prennent en charge différents niveaux de visibilité des modifications apportées par d'autres utilisateurs aux données de la base de données qui figurent dans le jeu de résultats.</p></li></ul><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Pour une description complète des types de curseurs SQL Server, consultez la rubrique sur les types de curseurs (Moteur de base de données) dans la documentation en ligne SQL Server.</p></div><p>La spécification JDBC fournit la prise en charge des curseurs avant uniquement et des curseurs déroulables qui sont sensibles ou insensibles aux modifications apportées par d'autres travaux et qui peuvent être en lecture seule ou mis à jour. Cette fonctionnalité est fournie par la classe <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a> du Pilote JDBC Microsoft pour SQL Server.</p></div><h1 class="heading">Notes</h1><div id="sectionSection0" class="section" name="collapseableSection" style=""><p>Le pilote JDBC prend en charge les types de curseurs suivants :</p><div class="tableSection"><table width="50%" cellspacing="2" cellpadding="5" frame="lhs"><tr><th><p>Type de jeu </p><p>de résultats (curseur)</p></th><th><p>Type de curseur SQL Server</p></th><th><p>Caractéristiques</p></th><th><p>Méthode</p><p>select</p></th><th><p>Mise en mémoire tampon</p><p>des réponses</p></th><th><p>Description</p></th></tr><tr><td><p>TYPE_FORWARD_ONLY (CONCUR_READ_ONLY)</p></td><td><p>Non applicable</p></td><td><p>Avant uniquement, lecture seule</p></td><td><p>directe</p></td><td><p>complète</p></td><td><p>L'application doit faire un passage unique (en avant) à travers le jeu de résultats. Il s'agit du comportement par défaut, identique à celui d'un curseur TYPE_SS_DIRECT_FORWARD_ONLY. Le pilote lit l'intégralité du jeu de résultats à partir du serveur dans une mémoire durant l'exécution de l'instruction. </p></td></tr><tr><td><p>TYPE_FORWARD_ONLY (CONCUR_READ_ONLY)</p></td><td><p>Non applicable</p></td><td><p>Avant uniquement, lecture seule</p></td><td><p>directe</p></td><td><p>adaptative</p></td><td><p>L'application doit faire un passage unique (en avant) à travers le jeu de résultats. Son comportement est identique à celui d'un curseur TYPE_SS_DIRECT_FORWARD_ONLY. Le pilote lit des lignes à partir du serveur à mesure que l'application les demande, ce qui réduit l'utilisation de la mémoire côté client.</p></td></tr><tr><td><p>TYPE_FORWARD_ONLY (CONCUR_READ_ONLY)</p></td><td><p>Avance rapide</p></td><td><p>Avant uniquement, lecture seule</p></td><td><p>curseur</p></td><td><p>Non applicable</p></td><td><p>L'application doit faire un passage unique (en avant) à travers le jeu de résultats en utilisant un curseur côté serveur. Son comportement est identique à celui d'un curseur TYPE_SS_SERVER_CURSOR_FORWARD_ONLY.</p><p>Les lignes sont récupérées à partir du serveur en blocs qui sont spécifiés par la taille de l'extraction.</p></td></tr><tr><td><p>TYPE_FORWARD_ONLY (CONCUR_UPDATABLE)</p></td><td><p>Dynamique (avant uniquement)</p></td><td><p>Avant uniquement, pouvant être mis à jour</p></td><td><p>Non applicable</p></td><td><p>Non applicable</p></td><td><p>L'application doit faire un passage unique (en avant) à travers le jeu de résultats pour mettre à jour une ou plusieurs lignes. </p><p>Les lignes sont récupérées à partir du serveur en blocs qui sont spécifiés par la taille de l'extraction.</p><p>Par défaut, la taille de l'extraction est fixe lorsque l'application appelle la méthode <a href="233bf4f8-4758-42d0-a80b-33e34fa78027.htm">setFetchSize</a> de l'objet <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a>. </p><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Le pilote JDBC propose une fonctionnalité de mise en mémoire tampon adaptative qui vous permet de récupérer les résultats de l'exécution des instructions à partir du serveur SQL Server chaque fois que l'application en a besoin, et non en une seule fois. Par exemple, si une application doit récupérer des données dont la taille est trop importante pour la mémoire de l'application, une mise en mémoire tampon adaptative permet à l'application cliente de récupérer ces données sous forme de flux. </p><p>Le comportement par défaut du pilote est « <span sdata="langKeyword" value="adaptive"><span class="keyword">adaptive</span></span> ». Toutefois, pour permettre la mise en mémoire tampon adaptative des jeux de résultats de type avant uniquement pouvant être mis à jour, l'application doit appeler explicitement la méthode <a href="9f489835-6cda-4c8c-b139-079639a169cf.htm">setResponseBuffering</a> de l'objet <a href="ec24963c-8b51-4838-91e9-1fbfa2347451.htm">SQLServerStatement</a> en fournissant une valeur <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> en mode "<span sdata="langKeyword" value="adaptive&quot;"><span class="keyword">adaptive"</span></span>. Pour obtenir un exemple de code, consultez <span sdata="link"><a href="76ecc05f-a77d-40a2-bab9-91a7fcf17347.htm">Exemple de mise à jour de données volumineuses</a></span>.</p></div></td></tr><tr><td><p>TYPE_SCROLL_INSENSITIVE</p></td><td><p>Statique</p></td><td><p>Déroulable, ne pouvant pas être mis à jour.</p><p>Les mises à jour, insertions et suppressions de lignes externes ne sont pas visibles.</p></td><td><p>Non applicable</p></td><td><p>Non applicable</p></td><td><p>L'application requiert un instantané de base de données. Le jeu de résultat ne peut pas être mis à jour. Seul CONCUR_READ_ONLY est pris en charge.  Tous les autres types d'accès simultanés provoqueront une exception en cas d'utilisation avec ce type de curseur.</p><p>Les lignes sont récupérées à partir du serveur en blocs qui sont spécifiés par la taille de l'extraction.</p></td></tr><tr><td><p>TYPE_SCROLL_SENSITIVE</p><p>(CONCUR_READ_ONLY)</p></td><td><p>Keyset</p></td><td><p>Déroulable, lecture seule. Les mises à jour de lignes externes sont visibles et les suppressions apparaissent comme données manquantes.</p><p>Les insertions de lignes externes ne sont pas visibles. </p></td><td><p>Non applicable</p></td><td><p>Non applicable</p></td><td><p>L'application doit voir les données modifiées uniquement pour les lignes existantes.</p><p>Les lignes sont récupérées à partir du serveur en blocs qui sont spécifiés par la taille de l'extraction.</p></td></tr><tr><td><p>TYPE_SCROLL_SENSITIVE</p><p>(CONCUR_UPDATABLE, CONCUR_SS_SCROLL_LOCKS, CONCUR_SS_OPTIMISTIC_CC, CONCUR_SS_OPTIMISTIC_CCVAL)</p></td><td><p>Keyset</p></td><td><p>Déroulable, pouvant être mis à jour. </p><p>Les mises à jour de lignes externes et internes sont visibles et les suppressions apparaissent comme des données manquantes ; les insertions ne sont pas visibles.</p></td><td><p>Non applicable</p></td><td><p>Non applicable</p></td><td><p>L'application peut modifier des données dans les lignes existantes à l'aide de l'objet <b>ResultSet</b>. L'application doit également être en mesure d'afficher les modifications apportées aux lignes par d'autres utilisateurs depuis l'extérieur de l'objet <b>ResultSet</b>.</p><p>Les lignes sont récupérées à partir du serveur en blocs qui sont spécifiés par la taille de l'extraction.</p></td></tr><tr><td><p>TYPE_SS_DIRECT_FORWARD_ONLY</p></td><td><p>Non applicable</p></td><td><p>Avant uniquement, lecture seule</p></td><td><p>Non applicable</p></td><td><p>complète ou adaptative</p></td><td><p>Valeur de type entier = 2003. Fournit un curseur côté client en lecture seule entièrement mis en mémoire tampon. Aucun curseur côté serveur n'est créé.</p><p>Seul le type d'accès simultané CONCUR_READ_ONLY est pris en charge. Tous les autres types d'accès simultanés provoquent une exception en cas d'utilisation avec ce type de curseur.</p></td></tr><tr><td><p>TYPE_SS_SERVER_CURSOR_FORWARD_ONLY</p></td><td><p>Avance rapide</p></td><td><p>Avant uniquement</p></td><td><p>Non applicable</p></td><td><p>Non applicable</p></td><td><p>Valeur de type entier = 2004. Rapide, accède à toutes les données à l'aide d'un curseur côté serveur. Il peut être mis à jour en cas d'utilisation avec le type d'accès simultané CONCUR_UPDATABLE.</p><p>Les lignes sont récupérées à partir du serveur en blocs qui sont spécifiés par la taille de l'extraction.</p><p>Pour recevoir la mise en mémoire tampon adaptative pour ce cas, l'application doit appeler explicitement la méthode <a href="9f489835-6cda-4c8c-b139-079639a169cf.htm">setResponseBuffering</a> de l'objet <a href="ec24963c-8b51-4838-91e9-1fbfa2347451.htm">SQLServerStatement</a> en fournissant une valeur <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> "<span sdata="langKeyword" value="adaptive&quot;"><span class="keyword">adaptive"</span></span>. Pour obtenir un exemple de code, consultez <span sdata="link"><a href="76ecc05f-a77d-40a2-bab9-91a7fcf17347.htm">Exemple de mise à jour de données volumineuses</a></span>.</p></td></tr><tr><td><p>TYPE_SS_SCROLL_STATIC</p></td><td><p>Statique</p></td><td><p>Les mises à jour des autres utilisateurs ne sont pas reflétées.</p></td><td><p>Non applicable</p></td><td><p>Non applicable</p></td><td><p>Valeur de type entier = 1004. L'application requiert une capture instantanée de base de données. Il s'agit du synonyme spécifique à SQL Server pour le curseur JDBC TYPE_SCROLL_INSENSITIVE, avec le même comportement du paramètre d'accès simultané.</p><p>Les lignes sont récupérées à partir du serveur en blocs qui sont spécifiés par la taille de l'extraction.</p></td></tr><tr><td><p>TYPE_SS_SCROLL_KEYSET</p><p>(CONCUR_READ_ONLY)</p></td><td><p>Keyset</p></td><td><p>Déroulable, lecture seule. Les mises à jour de lignes externes sont visibles et les suppressions apparaissent comme données manquantes.</p><p>Les insertions de lignes externes ne sont pas visibles.</p></td><td><p>Non applicable</p></td><td><p>Non applicable</p></td><td><p>Valeur de type entier = 1005. L'application doit voir les données modifiées uniquement pour les lignes existantes. Il s'agit du synonyme spécifique à SQL Server pour le curseur JDBC TYPE_SCROLL_SENSITIVE, avec le même comportement du paramètre d'accès simultané.</p><p>Les lignes sont récupérées à partir du serveur en blocs qui sont spécifiés par la taille de l'extraction.</p></td></tr><tr><td><p>TYPE_SS_SCROLL_KEYSET</p><p>(CONCUR_UPDATABLE, CONCUR_SS_SCROLL_LOCKS, CONCUR_SS_OPTIMISTIC_CC, CONCUR_SS_OPTIMISTIC_CCVAL)</p></td><td><p>Keyset</p></td><td><p>Déroulable, pouvant être mis à jour. </p><p>Les mises à jour de lignes externes et internes sont visibles et les suppressions apparaissent comme des données manquantes ; les insertions ne sont pas visibles.</p></td><td><p>Non applicable</p></td><td><p>Non applicable</p></td><td><p>Valeur de type entier = 1005. L'application doit modifier des données ou voir les données modifiées pour les lignes existantes. Il s'agit du synonyme spécifique à SQL Server pour le curseur JDBC TYPE_SCROLL_SENSITIVE, avec le même comportement du paramètre d'accès simultané.</p><p>Les lignes sont récupérées à partir du serveur en blocs qui sont spécifiés par la taille de l'extraction.</p></td></tr><tr><td><p>TYPE_SS_SCROLL_DYNAMIC</p><p>(CONCUR_READ_ONLY)</p></td><td><p>Dynamique</p></td><td><p>Déroulable, lecture seule. </p><p>Les mises à jour et les insertions de lignes externes sont visibles et les suppressions apparaissent comme des données manquantes transitoires dans la mémoire tampon d'extraction actuelle. </p></td><td><p>Non applicable</p></td><td><p>Non applicable</p></td><td><p>Valeur de type entier = 1006. L'application doit voir les données modifiées pour les lignes existantes et voir les lignes insérées et les lignes supprimées pendant la durée de vie du curseur.</p><p>Les lignes sont récupérées à partir du serveur en blocs qui sont spécifiés par la taille de l'extraction.</p></td></tr><tr><td><p>TYPE_SS_SCROLL_DYNAMIC</p><p>(CONCUR_UPDATABLE, CONCUR_SS_SCROLL_LOCKS, CONCUR_SS_OPTIMISTIC_CC, CONCUR_SS_OPTIMISTIC_CCVAL)</p></td><td><p>Dynamique</p></td><td><p>Déroulable, pouvant être mis à jour. </p><p>Les mises à jour et les insertions de lignes externes et internes sont visibles et les suppressions apparaissent comme des données manquantes transitoires dans la mémoire tampon d'extraction actuelle.</p></td><td><p>Non applicable</p></td><td><p>Non applicable</p></td><td><p>Valeur de type entier = 1006. L'application peut modifier des données pour les lignes existantes, ou insérer ou supprimer des lignes à l'aide de l'objet <b>ResultSet</b>. L'application doit également être en mesure d'afficher les modifications, insertions et suppressions apportées par d'autres utilisateurs depuis l'extérieur de l'objet <b>ResultSet</b>.</p><p>Les lignes sont récupérées à partir du serveur en blocs qui sont spécifiés par la taille de l'extraction.</p></td></tr></table></div></div><h1 class="heading">Positionnement du curseur</h1><div id="sectionSection1" class="section" name="collapseableSection" style=""><p>Les curseurs TYPE_FORWARD_ONLY, TYPE_SS_DIRECT_FORWARD_ONLY et TYPE_SS_SERVER_CURSOR_FORWARD_ONLY prennent en charge uniquement la méthode de positionnement <a href="60248447-6908-4036-a779-a501453cd553.htm">next</a> .</p><p>Le curseur TYPE_SS_SCROLL_DYNAMIC ne prend pas en charge les méthodes <a href="638e8148-8ca0-4e1f-9ec2-04a11bc9809b.htm">absolute</a> et <a href="a266e3bc-05c2-44e2-9346-125ae6780216.htm">getRow</a>. La méthode <b>absolute</b> peut être évaluée approximativement par une combinaison d'appels aux méthodes <a href="67ed9447-7b10-4c87-98e7-f4c2e2470b3a.htm">first</a> et <a href="2bcdbb69-95fd-4ae8-8488-1a75a91fe2e0.htm">relative</a> pour les curseurs dynamiques.</p><p>La méthode <b>getRow</b> est prise en charge uniquement par les curseurs TYPE_FORWARD_ONLY, TYPE_SS_DIRECT_FORWARD_ONLY, TYPE_SS_SERVER_CURSOR_FORWARD_ONLY, TYPE_SS_SCROLL_KEYSET et TYPE_SS_SCROLL_STATIC. La méthode <b>getRow</b> avec tous les types de curseurs avant uniquement retourne le nombre de lignes lues jusqu'à maintenant à travers le curseur.</p><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Lorsqu'une application effectue un appel de positionnement de curseur non pris en charge ou un appel non pris en charge à la méthode <b>getRow</b>, une exception est levée avec le message « L'opération demandée n'est pas prise en charge pour ce type de curseur ».</p></div><p>Seuls le curseur TYPE_SS_SCROLL_KEYSET et le curseur TYPE_SCROLL_SENSITIVE équivalent exposent les lignes supprimées. Si le curseur est positionné sur une ligne supprimée, les valeurs de colonne ne sont pas disponibles et la méthode <a href="9c6db315-e614-4604-b020-41af6a214cc1.htm">rowDeleted</a> retourne la valeur « true ». Les appels aux méthodes <b>get&lt;Type&gt;</b> lèvent une exception avec le message « Impossible d'obtenir une valeur à partir d'une ligne supprimée ». Les lignes supprimées ne peuvent pas être mises à jour. Si vous essayez d'appeler une méthode <b>update&lt;Type&gt;</b> sur une ligne supprimée, une exception est levée avec le message « Une ligne supprimée ne peut pas être mise à jour ». Le curseur TYPE_SS_SCROLL_DYNAMIC a le même comportement jusqu'à ce qu'il soit déplacé hors de la mémoire tampon d'extraction actuelle.</p><p>Les curseurs dynamiques et avant exposent les lignes supprimées de manière semblable, mais uniquement tant qu'ils restent accessibles dans la mémoire tampon d'extraction. Pour les curseurs avant, c'est assez simple. Pour les curseurs dynamiques, c'est plus complexe lorsque la taille de l'extraction est supérieure à 1. Une application peut déplacer le curseur vers l'avant et vers l'arrière dans la fenêtre définie par la mémoire tampon d'extraction, mais la ligne supprimée disparaîtra lorsque la mémoire tampon d'extraction d'origine dans laquelle elle a été mise à jour sera quittée. Si une application ne souhaite pas voir les lignes supprimées temporaires à l'aide de curseurs dynamiques, un relatif d'extraction (0) doit être utilisé.</p><p>Si les valeurs de clés d'une ligne de curseur TYPE_SS_SCROLL_KEYSET ou TYPE_SCROLL_SENSITIVE sont mises à jour avec le curseur, la ligne conserve sa position d'origine dans le jeu de résultats, même si la ligne mise à jour ne satisfait pas aux critères de sélection du curseur. Si la ligne a été mise à jour à l'extérieur du curseur, une ligne supprimée apparaît à la position d'origine de la ligne, mais cette ligne apparaît dans le curseur uniquement si une autre ligne avec les nouvelles valeurs de clés était présente dans le curseur mais a été supprimée depuis. </p><p>Pour les curseurs dynamiques, les lignes mises à jour conservent leur position dans la mémoire tampon d'extraction jusqu'à ce que la fenêtre définie par la mémoire tampon d'extraction soit quittée. Les lignes mises à jour peuvent réapparaître par la suite à des positions différentes dans le jeu de résultats ou peuvent disparaître complètement. Les applications qui doivent éviter les incohérences transitoires dans le jeu de résultats doivent utiliser une taille d'extraction de 1 (la valeur par défaut est 8 lignes avec l'accès simultané CONCUR_SS_SCROLL_LOCKS et 128 lignes avec d'autres accès simultanés).</p></div><h1 class="heading">Conversion de curseur</h1><div id="sectionSection2" class="section" name="collapseableSection" style=""><p>SQL Server peut parfois choisir d'implémenter un type de curseur autre que celui demandé ; on appelle cela la conversion de curseur implicite (ou dégradation de curseur). Pour plus d'informations sur la conversion de curseur implicite, consultez la rubrique relative à l'utilisation des conversions de curseurs dans la documentation en ligne de SQL Server.</p><p>Avec SQL Server 2000, lorsque vous mettez à jour les données par le biais des jeux de résultats <b>ResultSet.TYPE_SCROLL_SENSITIVE</b> et <b>ResultSet.CONCUR_UPDATABLE</b>, une exception est levée avec un message « Le curseur est READ ONLY ». Cette exception se produit car SQL Server 2000 a effectué une conversion de curseur implicite pour ce jeu de résultats et n'a pas retourné le curseur pouvant être mis à jour qui a été demandé.</p><p>Pour contourner ce problème, vous pouvez choisir l'une des deux solutions suivantes :</p><ul><li><p>Assurez-vous que la table sous-jacente a une clé primaire</p></li><li><p>Utilisez <a href="d87afd89-3e75-402c-b844-1b434eb258df.htm">SQLServerResultSet.TYPE_SS_SCROLL_DYNAMIC</a> au lieu de <b>ResultSet.TYPE_SCROLL_SENSITIVE</b> lors de la création d'une instruction.</p></li></ul></div><h1 class="heading">Mise à jour de curseur</h1><div id="sectionSection3" class="section" name="collapseableSection" style=""><p>Les mises à jour sur place sont prises en charge pour les curseurs où le type de curseur et l'accès simultané prennent en charge les mises à jour. Si le curseur n'est pas positionné sur une ligne pouvant être mise à jour dans le jeu de résultats (aucun appel de méthode <b>get&lt;Type&gt;</b> n'a réussi), un appel à une méthode <b>update&lt;Type&gt;</b> lève une exception avec le message « Le jeu de résultat n'a pas de ligne actuelle ». La spécification JDBC stipule qu'une exception survient lorsqu'une méthode de mise à jour est appelée pour une colonne d'un curseur qui est CONCUR_READ_ONLY. Dans les situations où la ligne ne peut pas être mise à jour, par exemple à cause d'un conflit d'accès simultané optimiste tel qu'une mise à jour ou une suppression en concurrence, l'exception peut ne pas survenir avant un appel à <a href="363d1008-1396-4fc0-8e27-c9ba2499e7f1.htm">insertRow</a>, <a href="cfced0ca-a281-40dc-8d2f-370d5f0bf12b.htm">updateRow</a> ou <a href="aa04a644-c7c2-4738-8b6e-7fea566d2c16.htm">deleteRow</a>.</p><p>Après un appel à <b>update&lt;Type&gt;</b>, la colonne affectée est accessible par <b>get&lt;Type&gt;</b> uniquement une fois que <b>updateRow</b> ou <a href="2ecacca4-f7bc-4f5d-886a-da7747fdccae.htm">cancelRowUpdates</a> a été appelée. Cela évite les problèmes selon lesquels une colonne est mise à jour en utilisant un type différent du type retourné par le serveur, et les appels d'accesseur Get suivants pourraient appeler des conversions de type côté client donnant des résultats inexacts. Les appels à <b>get&lt;Type&gt;</b> lèveront une exception avec le message « Impossible d'accéder aux colonnes mises à jour tant que updateRow() ou cancelRowUpdates() n'a pas été appelé ».</p><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Si la méthode <b>updateRow</b> est appelée lorsque aucune colonne n'a été mise à jour, le pilote JDBC lève une exception avec un message indiquant que updateRow() a été appelée alors qu'aucune colonne n'a été mise à jour.</p></div><p>Après l'appel à <a href="f3c54bfe-d5b7-4f6e-ae6c-3e8954e5b1c9.htm">moveToInsertRow</a>, une exception est levée si une méthode autre que <b>get&lt;Type&gt;</b>, <b>update&lt;Type&gt;</b>, <b>insertRow,</b> et des méthodes de positionnement de curseur (y compris <a href="9a7c754c-2d72-4207-b3bd-2afc6047fb3d.htm">moveToCurrentRow</a>) sont appelées sur le jeu de résultats. La méthode <b>moveToInsertRow</b> place le jeu de résultats en mode insertion et les méthodes de positionnement de curseur mettent fin au mode insertion. Les appels de positionnement de curseur relatif déplacent le curseur relativement à la position dans laquelle il était avant l'appel à <b>moveToInsertRow</b>. Après les appels de positionnement de curseur, la position de curseur de destination finale devient la nouvelle position de curseur.</p><p>Si l'appel de positionnement de curseur effectué lors du mode insertion ne réussit pas, la position du curseur après l'appel échoué est la position de curseur d'origine avant l'appel à <b>moveToInsetRow</b>. Si <b>insertRow</b> échoue, le curseur reste sur la ligne d'insertion et il reste en mode insertion.</p><p>Les colonnes dans la ligne d'insertion sont initialement dans un état non initialisé. Les appels à la méthode <b>update&lt;Type&gt;</b> définissent l'état de colonne à « initialisée ». Un appel à la méthode <b>get&lt;Type&gt;</b> pour une colonne non initialisée lève une exception. Un appel à la méthode <b>insertRow</b> retourne toutes les colonnes dans la ligne d'insertion à un état non initialisé.</p><p>Si des colonnes ne sont pas initialisées lorsque la méthode <b>insertRow</b> est appelée, la valeur par défaut pour la colonne est insérée. S'il n'y a aucune valeur par défaut mais que la colonne est nullable, la valeur NULL est insérée. S'il n'y a aucune valeur par défaut et que la colonne n'est pas nullable, le serveur retourne une erreur et une exception est levée.</p><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p /><p>Les appels à la méthode <b>getRow</b> retournent 0 en mode insertion. </p><p>Le pilote JDBC ne prend pas en charge les mises à jour ou les suppressions positionnées. D'après la spécification JDBC, la méthode <a href="3f3ec4f2-103a-4e16-9206-c5bd8639f946.htm">setCursorName</a> n'a aucun effet et la méthode <a href="e5b3af67-423a-4551-a4c6-a4bc076bd504.htm">getCursorName</a> lève une exception si elle est appelée. </p><p>Les curseurs en lecture seule et statiques ne peuvent jamais être mis à jour. </p><p>SQL Server restreint les curseurs côté serveur à un seul jeu de résultats. Si une procédure de lot ou une procédure stockée contient plusieurs instructions, un curseur client en lecture seule avant uniquement doit être utilisé.</p></div></div><span id="seeAlsoSpan"><h1 class="heading">Voir aussi</h1></span><div id="seeAlsoSection" class="section" name="collapseableSection" style=""><div class="seeAlsoStyle"><span sdata="link"><a href="9ed5ad41-22e0-4e4a-8a79-10512db60d50.htm">Gestion de jeux de résultats avec le pilote JDBC</a></span></div></div></div><div id="footer" class="section"><span id="feedbackarea">Envoyez vos <a href="javascript:SubmitFeedback('DevDocs@Microsoft.com','','','','8.0.12060.10000','%0\dMerci pour vos commentaires qui permettent aux équipes chargées de rédiger la documentation développeur d\'en améliorer la qualité. Pendant la révision de vos commentaires, il est possible que nous vous contactions par courrier électronique afin de vous demander des éclaircissements ou d\'autres commentaires sur la solution envisagée. Nous n\'utilisons pas votre adresse de messagerie dans un autre but et nous la supprimons une fois notre révision terminée.%0\APour plus d\'informations sur les politiques de confidentialité de Microsoft, consultez http://privacy.microsoft.com/fr-fr/default.aspx.%0\A%0\d','Commentaires client.');">commentaires</a> sur cette rubrique à Microsoft.</span><span id="copyrightarea"><p><a href="9bad553b-9e70-4696-8499-2e35f772a1e0.htm">© 2012 Microsoft. Tous droits réservés.</a></p></span></div></div></body></html>